# Description

该仓库用于记录各种算法及其实现：

- Greedy：贪心算法
- DC(Divide and conquer)：分治算法
- DP(Dynamic programming)：动态规划

# 贪心算法

## 区间调度问题

给定若干个闭区间，计算这些区间中最多有几个互不相交的区间。

该问题共有多个贪心策略，正确的策略是贪心选择**最早结束的活动区间**。

![证明贪心即最优](https://happytsing-figure-bed.oss-cn-hangzhou.aliyuncs.com/uestc/advanced_algorithm/image-20221203153348736.png)

假设 $i_1$, $i_2$,...,$i_r$ 的选择上贪心策略和最优策略相同，当选择 $i_{r+1}$ 时，如图所示，如果贪心和最优的选择不同，此时贪心的选择才是最优选择。

由此证明了，贪心策略就是最优策略。

算法：

- 按照结束时间排序
- 遍历所有区间，若不冲突，则选择。

> 当区间含有权重时，需要使用动态规划。

## 硬币兑换问题

给定若干个数值的硬币，计算最少需要多少个硬币，可以兑换出给定金额。

eg1:

- currency = 1, 5, 10, 25, 100
- total = 140

此时贪心选择面额最大的硬币即可，即：100, 25, 10, 5

但若硬币的面额特殊一点，就无法使用贪心算法。

eg2:

- currency = 1, 5, 10, 25, 70, 100
- total = 140

此时贪心算法会得到 eg1 的结果，但最优解是：70, 70

其原因是，货币之间的兑换关系不同。

## 背包问题

给定 n 个物品和一个容量为 C 的背包，物品 i 的重量是 Wi,其价值为 Vi,背包问题是如何选择入背包的物品，使得装入背包的物品的总价值最大，注意和0/1背包的区别，在背包问题中可以将物品的一部分装入背包，但不能重复装入。

正确的贪心策略是选择单位价值最大的物品放入背包。

注意：若为 01 背包，即要么全部放入，要么不选择，则不能使用贪心算法，而必须动态规划。

## 最优装载

有一批集装箱要装上一艘载重量为 C 的轮船。其中集装箱 i 的重量为 Wi。最优装载问题要求确定在 **装载体积不受限制** 的情况下，将尽可能多的集装箱装上轮船。

贪心策略：由于体积不限，因此采用重量最轻者先装的贪心选择策略。

> 该问题和背包问题本质上是相同的

## 单源最短路径

给定 **带权有向图**  G =(V,E)，其中每条边的权是非负实数。另外，还给定V中的一个顶点，称为源。现在要计算从源到所有其他各顶点的最短路长度。这里路的长度是指路上各边权之和。这个问题通常称为单源最短路径问题。

Dijkstra 算法是解单源最短路径问题的贪心算法。

其基本思想是，设置顶点集合S并不断地作贪心选择来扩充这个集合。一个顶点属于集合S当且仅当从源到该顶点的最短路径长度已知。
		
- 初始时，S中仅含有源
- 设u是G的某一个顶点，把从源到u且中间只经过S中顶点的路称为从源到u的特殊路径，并用数组dist记录当前每个顶点所对应的最短特殊路径长度
- Dijkstra算法每次从V-S中取出具有最短特殊路长度的顶点u，将u添加到S中，同时对数组dist作必要的修改。
- 一旦S包含了所有V中顶点，dist就记录了从源到所有其他顶点之间的最短路径长度。

## 最小生成树

给定 **带权无向连通图** G =(V,E)，即一个网络。E 中每条边 (v,w) 的权为 c[v][w]。如果 G 的子图 G’ 是一棵 **包含 G 的所有顶点的树** ，则称 G’ 为 G 的生成树。

生成树上各边权的总和称为该生成树的耗费。在 G 的所有生成树中，**耗费最小的生成树称为 G 的最小生成树**

构造最小生成树的 Prim 算法和 Kruskal 算法均为贪心算法设计策略，都利用了最小生成树的性质：

设 G=(V,E) 是连通带权图，U是V的真子集。如果 (u,v)∈E，且 u∈U，v∈V-U，且在所有这样的边中，(u,v) 的权 c[u][v]最小，那么一定存在 G 的一棵最小生成树，它以(u,v)为其中一条边，该性质称为 **MST 性质**。

### Prim 算法
### Kruskal 算法

todo 参考 ppt 贪心算法实例合集
# 分治算法
https://www.cnblogs.com/chihaoyuIsnotHere/p/10129475.html